# Explore Service

## Overview

Explore Service is a high-performance gRPC microservice for managing user relationships in a dating application. It enables users to express interest in other users through "likes" and "passes", and provides endpoints to view users who have liked them.

## Features

- Record user decisions (likes/passes) on other users' profiles
- Retrieve lists of users who have liked a specific user
- Filter to show only users who have liked a user but haven't been liked back
- Count the number of users who have liked a specific user
- Check for mutual likes when recording decisions
- Efficient pagination using cursor-based approach
- Support for high-scale usage (users with hundreds of thousands of decisions)

## Architecture

The service is built with a clean architecture approach:

- **gRPC API Layer**: Handles incoming requests and response formatting
- **Repository Layer**: Manages data access and persistence
- **Entity Layer**: Defines domain models and business rules
- **Database Layer**: Abstracts database connection management

## API Endpoints

The service implements four gRPC endpoints as defined in the protocol buffer:

1. `ListLikedYou`: Lists all users who liked the specified recipient
2. `ListNewLikedYou`: Lists users who liked the recipient but haven't been liked back
3. `CountLikedYou`: Counts the number of users who liked the recipient
4. `PutDecision`: Records a user's decision (like or pass) about another user

### Example Requests and Responses

#### ListLikedYou

Request (initial):
```json
{
  "recipient_user_id": "1",
  "pagination_token": null
}
```

Response:
```json
{
  "likers": [
    {
      "actor_id": "10",
      "unix_timestamp": 1738754100
    },
    {
      "actor_id": "9",
      "unix_timestamp": 1738686000
    },
    {
      "actor_id": "7",
      "unix_timestamp": 1738511100
    },
    {
      "actor_id": "6",
      "unix_timestamp": 1738404600
    },
    {
      "actor_id": "5",
      "unix_timestamp": 1738057800
    },
    {
      "actor_id": "3",
      "unix_timestamp": 1737621000
    },
    {
      "actor_id": "2",
      "unix_timestamp": 1737390600
    }
  ]
}
```

Request (with pagination):
```json
{
  "recipient_user_id": "1",
  "pagination_token": "eyJ1cGRhdGVkX2F0IjoiMjAyNS0wMi0wMiAxNTo0NTowMCIsImFjdG9yX2lkIjoiNyJ9"
}
```

Response:
```json
{
  "likers": [
    {
      "actor_id": "6",
      "unix_timestamp": 1738404600
    },
    {
      "actor_id": "5",
      "unix_timestamp": 1738057800
    },
    {
      "actor_id": "3",
      "unix_timestamp": 1737621000
    },
    {
      "actor_id": "2",
      "unix_timestamp": 1737390600
    }
  ],
  "next_pagination_token": "eyJ1cGRhdGVkX2F0IjoiMjAyNS0wMS0yMyAwODozMDowMCIsImFjdG9yX2lkIjoiMyJ9"
}
```

#### ListNewLikedYou

Request (initial):
```json
{
  "recipient_user_id": "1",
  "pagination_token": null
}
```

Response:
```json
{
  "likers": [
    {
      "actor_id": "6",
      "unix_timestamp": 1738404600
    },
    {
      "actor_id": "10",
      "unix_timestamp": 1738754100
    },
    {
      "actor_id": "9",
      "unix_timestamp": 1738686000
    }
  ]
}
```

#### CountLikedYou

Request:
```json
{
  "recipient_user_id": "1"
}
```

Response:
```json
{
  "count": 7
}
```

#### PutDecision

Request:
```json
{
  "actor_user_id": "1",
  "recipient_user_id": "2",
  "liked_recipient": true
}
```

Response:
```json
{
  "mutual_likes": true
}
```

## Technical Implementation

### Database Schema

```sql
CREATE TABLE user_decisions (
    actor_id VARCHAR(255) NOT NULL,
    recipient_id VARCHAR(255) NOT NULL,
    liked BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (actor_id, recipient_id),
    INDEX idx_recipient_liked (recipient_id, liked),
    INDEX idx_recipient_updated (recipient_id, updated_at, actor_id)
);
```

### Cursor-Based Pagination

For efficient pagination of large result sets, the service uses cursor-based pagination:

- Each page request can include an optional pagination token
- The token encodes the timestamp and actor_id of the last item from the previous page
- This approach is more efficient than offset-based pagination for large datasets

### Performance Considerations

- Optimized database queries with appropriate indexes
- Efficient handling of mutual likes check using transactions
- Cursor-based pagination for consistent performance with large datasets
- Connection pooling for database access

## Deployment

### Prerequisites

- Go 1.19+
- MySQL 8.0+
- Docker and Docker Compose (for containerized deployment)

### Environment Variables

The service uses the following environment variables for configuration:

- `DB_USER`: Database username
- `DB_PASS`: Database password
- `DB_HOST`: Database hostname
- `DB_PORT`: Database port
- `DB_NAME`: Database name
- `GRPC_PORT`: Port for the gRPC server

### Running with Docker Compose

```bash
# Start the service
docker-compose up -d

# Stop the service
docker-compose down
```

### Running locally

```bash
# Build the service
go build -o main .

# Run the service
./main serve grpc
```

## Testing

To run the test suite:

```bash
go test ./...
```

Sample data for testing can be loaded using:

```bash
# Copy seed file to container
docker cp seed-data.sql mysqldb:/tmp/

# Execute seed file
docker exec -it mysqldb bash -c "mysql -utest -ptest explore_muzz < /tmp/seed-data.sql"
```

## Design Decisions and Assumptions

1. **Composite Primary Key**: Using actor_id and recipient_id as a composite primary key ensures each user can have only one decision about another user.

2. **TEXT vs VARCHAR**: VARCHAR is used for ID columns since they are used in indices and have a known maximum length.

3. **Decision Overwriting**: If a user changes their mind, the existing decision can be overwritten by a new one.

4. **Cursor-Based Pagination**: This approach was chosen for its scalability with large datasets.

5. **Transaction for Mutual Likes**: The mutual like check is performed within a transaction to ensure data consistency.

6. **Error Handling**: Comprehensive error handling and informative error messages are provided.

Request (with pagination):
```json
{
  "recipient_user_id": "1",
  "pagination_token": "eyJ1cGRhdGVkX2F0IjoiMjAyNS0wMi0wMSAxMDoxMDowMCIsImFjdG9yX2lkIjoiNiJ9"
}
```

Response:
```json
{
  "likers": [
    {
      "actor_id": "9",
      "unix_timestamp": 1738686000
    }
  ],
  "next_pagination_token": null
}
```

#### CountLikedYou

Request:
```json
{
  "recipient_user_id": "1"
}
```

Response:
```json
{
  "count": 7
}
```

#### PutDecision

Request:
```json
{
  "actor_user_id": "1",
  "recipient_user_id": "2",
  "liked_recipient": true
}
```

Response:
```json
{
  "mutual_likes": true
}
```

## Technical Implementation

### Database Schema

```sql
CREATE TABLE user_decisions (
    actor_id VARCHAR(255) NOT NULL,
    recipient_id VARCHAR(255) NOT NULL,
    liked BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (actor_id, recipient_id),
    INDEX idx_recipient_liked (recipient_id, liked),
    INDEX idx_recipient_updated (recipient_id, updated_at, actor_id)
);
```

### Cursor-Based Pagination

For efficient pagination of large result sets, the service uses cursor-based pagination:

- Each page request can include an optional pagination token
- The token encodes the timestamp and actor_id of the last item from the previous page
- This approach is more efficient than offset-based pagination for large datasets

### Performance Considerations

- Optimized database queries with appropriate indexes
- Efficient handling of mutual likes check using transactions
- Cursor-based pagination for consistent performance with large datasets
- Connection pooling for database access

## Deployment

### Prerequisites

- Go 1.19+
- MySQL 8.0+
- Docker and Docker Compose (for containerized deployment)

### Environment Variables

The service uses the following environment variables for configuration:

- `DB_USER`: Database username
- `DB_PASS`: Database password
- `DB_HOST`: Database hostname
- `DB_PORT`: Database port
- `DB_NAME`: Database name
- `GRPC_PORT`: Port for the gRPC server

### Running with Docker Compose

```bash
# Start the service
docker-compose up -d

# Stop the service
docker-compose down
```

### Running locally

```bash
# Build the service
go build -o main .

# Run the service
./main serve grpc
```

## Testing

To run the test suite:

```bash
go test ./...
```

Sample data for testing can be loaded using:

```bash
# Copy seed file to container
docker cp seed-data.sql mysqldb:/tmp/

# Execute seed file
docker exec -it mysqldb bash -c "mysql -utest -ptest explore_muzz < /tmp/seed-data.sql"
```

## Design Decisions and Assumptions

1. **Composite Primary Key**: Using actor_id and recipient_id as a composite primary key ensures each user can have only one decision about another user.

2. **TEXT vs VARCHAR**: VARCHAR is used for ID columns since they are used in indices and have a known maximum length.

3. **Decision Overwriting**: If a user changes their mind, the existing decision can be overwritten by a new one.

4. **Cursor-Based Pagination**: This approach was chosen for its scalability with large datasets.

5. **Transaction for Mutual Likes**: The mutual like check is performed within a transaction to ensure data consistency.

6. **Error Handling**: Comprehensive error handling and informative error messages are provided.
